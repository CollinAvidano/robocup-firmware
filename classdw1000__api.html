<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>GT RoboCup SSL: dw1000_api Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="rj_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GT RoboCup SSL
   </div>
   <div id="projectbrief">Soccer software, robot firmware</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classdw1000__api.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classdw1000__api-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">dw1000_api Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for dw1000_api:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classdw1000__api__inherit__graph.png" border="0" usemap="#dw1000__api_inherit__map" alt="Inheritance graph"/></div>
<map name="dw1000__api_inherit__map" id="dw1000__api_inherit__map">
<area shape="rect" id="node2" href="class_decawave.html" title="Decawave" alt="" coords="11,80,97,107"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdw1000__api_1_1dwt__local__data__t.html">dwt_local_data_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a21c8d7d3feaf9a49a782dfaf05ba47c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21c8d7d3feaf9a49a782dfaf05ba47c1"></a>
typedef void(dw1000_api::*&#160;</td><td class="memItemRight" valign="bottom"><b>dwt_cb_t</b>) (const <a class="el" href="structdwt__cb__data__t.html">dwt_cb_data_t</a> *)</td></tr>
<tr class="separator:a21c8d7d3feaf9a49a782dfaf05ba47c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a11ce0db640417c3c7e9545e903c6c63b"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#a11ce0db640417c3c7e9545e903c6c63b">dwt_getpartid</a> (void)</td></tr>
<tr class="memdesc:a11ce0db640417c3c7e9545e903c6c63b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to return the read part ID of the device.  <a href="#a11ce0db640417c3c7e9545e903c6c63b">More...</a><br /></td></tr>
<tr class="separator:a11ce0db640417c3c7e9545e903c6c63b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf621b142937858869b2006aeffc8a44"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#aaf621b142937858869b2006aeffc8a44">dwt_getlotid</a> (void)</td></tr>
<tr class="memdesc:aaf621b142937858869b2006aeffc8a44"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to return the read lot ID of the device.  <a href="#aaf621b142937858869b2006aeffc8a44">More...</a><br /></td></tr>
<tr class="separator:aaf621b142937858869b2006aeffc8a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a522b01e864c59d6d1b63fdec17a3d84c"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#a522b01e864c59d6d1b63fdec17a3d84c">dwt_readdevid</a> (void)</td></tr>
<tr class="memdesc:a522b01e864c59d6d1b63fdec17a3d84c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to return the read device type and revision information of the DW1000 device (MP part is 0xDECA0130)  <a href="#a522b01e864c59d6d1b63fdec17a3d84c">More...</a><br /></td></tr>
<tr class="separator:a522b01e864c59d6d1b63fdec17a3d84c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7624eff5817f4ce5813f2234b0dfb527"><td class="memItemLeft" align="right" valign="top">uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#a7624eff5817f4ce5813f2234b0dfb527">dwt_otprevision</a> (void)</td></tr>
<tr class="memdesc:a7624eff5817f4ce5813f2234b0dfb527"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to return the read OTP revision.  <a href="#a7624eff5817f4ce5813f2234b0dfb527">More...</a><br /></td></tr>
<tr class="separator:a7624eff5817f4ce5813f2234b0dfb527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3805ef20b4a000288da6e9917c35afb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#a3805ef20b4a000288da6e9917c35afb6">dwt_setfinegraintxseq</a> (int enable)</td></tr>
<tr class="memdesc:a3805ef20b4a000288da6e9917c35afb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables/disables the fine grain TX sequencing (enabled by default).  <a href="#a3805ef20b4a000288da6e9917c35afb6">More...</a><br /></td></tr>
<tr class="separator:a3805ef20b4a000288da6e9917c35afb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa39ce1feb99e92b21eb41138c760526"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#aaa39ce1feb99e92b21eb41138c760526">dwt_setlnapamode</a> (int lna, int pa)</td></tr>
<tr class="memdesc:aaa39ce1feb99e92b21eb41138c760526"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to enable GPIO for external LNA or PA functionality - HW dependent, consult the DW1000 User Manual. This can also be used for debug as enabling TX and RX GPIOs is quite handy to monitor DW1000's activity.  <a href="#aaa39ce1feb99e92b21eb41138c760526">More...</a><br /></td></tr>
<tr class="separator:aaa39ce1feb99e92b21eb41138c760526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82aac601a54c569d7bc6a74deacb5b02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#a82aac601a54c569d7bc6a74deacb5b02">dwt_setgpiodirection</a> (uint32 gpioNum, uint32 direction)</td></tr>
<tr class="memdesc:a82aac601a54c569d7bc6a74deacb5b02"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to set GPIO direction as an input (1) or output (0)  <a href="#a82aac601a54c569d7bc6a74deacb5b02">More...</a><br /></td></tr>
<tr class="separator:a82aac601a54c569d7bc6a74deacb5b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d20df2f7ff11cd107e70c56ad2ab89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#a04d20df2f7ff11cd107e70c56ad2ab89">dwt_setgpiovalue</a> (uint32 gpioNum, uint32 value)</td></tr>
<tr class="memdesc:a04d20df2f7ff11cd107e70c56ad2ab89"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to set GPIO value as (1) or (0) only applies if the GPIO is configured as output.  <a href="#a04d20df2f7ff11cd107e70c56ad2ab89">More...</a><br /></td></tr>
<tr class="separator:a04d20df2f7ff11cd107e70c56ad2ab89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a9391f974438b95468c2e3d62b05760"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#a0a9391f974438b95468c2e3d62b05760">dwt_initialise</a> (uint16 config)</td></tr>
<tr class="memdesc:a0a9391f974438b95468c2e3d62b05760"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initiates communications with the DW1000 transceiver and reads its DEV_ID register (address 0x00) to verify the IC is one supported by this software (e.g. DW1000 32-bit device ID value is 0xDECA0130). Then it does any initial once only device configurations needed for use and initialises as necessary any static data items belonging to this low-level driver.  <a href="#a0a9391f974438b95468c2e3d62b05760">More...</a><br /></td></tr>
<tr class="separator:a0a9391f974438b95468c2e3d62b05760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb1c479d9cc24d3f204f500040efa18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#aecb1c479d9cc24d3f204f500040efa18">dwt_configure</a> (<a class="el" href="structdwt__config__t.html">dwt_config_t</a> *config)</td></tr>
<tr class="memdesc:aecb1c479d9cc24d3f204f500040efa18"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function provides the main API for the configuration of the DW1000 and this low-level driver. The input is a pointer to the data structure of type dwt_config_t that holds all the configurable items. The dwt_config_t structure shows which ones are supported.  <a href="#aecb1c479d9cc24d3f204f500040efa18">More...</a><br /></td></tr>
<tr class="separator:aecb1c479d9cc24d3f204f500040efa18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489eba8c79d3539e46352f626568b523"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#a489eba8c79d3539e46352f626568b523">dwt_configuretxrf</a> (<a class="el" href="structdwt__txconfig__t.html">dwt_txconfig_t</a> *config)</td></tr>
<tr class="memdesc:a489eba8c79d3539e46352f626568b523"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function provides the API for the configuration of the TX spectrum including the power and pulse generator delay. The input is a pointer to the data structure of type dwt_txconfig_t that holds all the configurable items.  <a href="#a489eba8c79d3539e46352f626568b523">More...</a><br /></td></tr>
<tr class="separator:a489eba8c79d3539e46352f626568b523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb5075d5880708ab2672fc68a88b3b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#abcb5075d5880708ab2672fc68a88b3b4">dwt_setrxantennadelay</a> (uint16 antennaDly)</td></tr>
<tr class="memdesc:abcb5075d5880708ab2672fc68a88b3b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API function writes the antenna delay (in time units) to RX registers.  <a href="#abcb5075d5880708ab2672fc68a88b3b4">More...</a><br /></td></tr>
<tr class="separator:abcb5075d5880708ab2672fc68a88b3b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c013846be8715310e949145474c5612"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#a8c013846be8715310e949145474c5612">dwt_settxantennadelay</a> (uint16 antennaDly)</td></tr>
<tr class="memdesc:a8c013846be8715310e949145474c5612"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API function writes the antenna delay (in time units) to TX registers.  <a href="#a8c013846be8715310e949145474c5612">More...</a><br /></td></tr>
<tr class="separator:a8c013846be8715310e949145474c5612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af11b146a383c44470807a7badfe3af05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#af11b146a383c44470807a7badfe3af05">dwt_setsmarttxpower</a> (int enable)</td></tr>
<tr class="memdesc:af11b146a383c44470807a7badfe3af05"><td class="mdescLeft">&#160;</td><td class="mdescRight">This call enables or disables the smart TX power feature.  <a href="#af11b146a383c44470807a7badfe3af05">More...</a><br /></td></tr>
<tr class="separator:af11b146a383c44470807a7badfe3af05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a720f3107cf837ce51963e1c1b0aa1925"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#a720f3107cf837ce51963e1c1b0aa1925">dwt_writetxdata</a> (uint16 txFrameLength, uint8 *txFrameBytes, uint16 txBufferOffset)</td></tr>
<tr class="memdesc:a720f3107cf837ce51963e1c1b0aa1925"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API function writes the supplied TX data into the DW1000's TX buffer. The input parameters are the data length in bytes and a pointer to those data bytes.  <a href="#a720f3107cf837ce51963e1c1b0aa1925">More...</a><br /></td></tr>
<tr class="separator:a720f3107cf837ce51963e1c1b0aa1925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d450425dbd8c01d0029deca391d3913"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#a6d450425dbd8c01d0029deca391d3913">dwt_writetxfctrl</a> (uint16 txFrameLength, uint16 txBufferOffset, int ranging)</td></tr>
<tr class="memdesc:a6d450425dbd8c01d0029deca391d3913"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API function configures the TX frame control register before the transmission of a frame.  <a href="#a6d450425dbd8c01d0029deca391d3913">More...</a><br /></td></tr>
<tr class="separator:a6d450425dbd8c01d0029deca391d3913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9207625a29c31c96fe40b1a2485eba7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#aa9207625a29c31c96fe40b1a2485eba7">dwt_starttx</a> (uint8 mode)</td></tr>
<tr class="memdesc:aa9207625a29c31c96fe40b1a2485eba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This call initiates the transmission, input parameter indicates which TX mode is used see below.  <a href="#aa9207625a29c31c96fe40b1a2485eba7">More...</a><br /></td></tr>
<tr class="separator:aa9207625a29c31c96fe40b1a2485eba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef63c9c3329bef4e5e5700daa56254b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#aef63c9c3329bef4e5e5700daa56254b8">dwt_setdelayedtrxtime</a> (uint32 starttime)</td></tr>
<tr class="memdesc:aef63c9c3329bef4e5e5700daa56254b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API function configures the delayed transmit time or the delayed RX on time.  <a href="#aef63c9c3329bef4e5e5700daa56254b8">More...</a><br /></td></tr>
<tr class="separator:aef63c9c3329bef4e5e5700daa56254b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadd7a5a50c8a581d221d665120de1e56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#aadd7a5a50c8a581d221d665120de1e56">dwt_readtxtimestamp</a> (uint8 *timestamp)</td></tr>
<tr class="memdesc:aadd7a5a50c8a581d221d665120de1e56"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to read the TX timestamp (adjusted with the programmed antenna delay)  <a href="#aadd7a5a50c8a581d221d665120de1e56">More...</a><br /></td></tr>
<tr class="separator:aadd7a5a50c8a581d221d665120de1e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08fbdf70d9aa5cb3b03584cb5be0fe07"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#a08fbdf70d9aa5cb3b03584cb5be0fe07">dwt_readtxtimestamphi32</a> (void)</td></tr>
<tr class="memdesc:a08fbdf70d9aa5cb3b03584cb5be0fe07"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to read the high 32-bits of the TX timestamp (adjusted with the programmed antenna delay)  <a href="#a08fbdf70d9aa5cb3b03584cb5be0fe07">More...</a><br /></td></tr>
<tr class="separator:a08fbdf70d9aa5cb3b03584cb5be0fe07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd2c43ace112d8f6092f12750e2276cf"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#abd2c43ace112d8f6092f12750e2276cf">dwt_readtxtimestamplo32</a> (void)</td></tr>
<tr class="memdesc:abd2c43ace112d8f6092f12750e2276cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to read the low 32-bits of the TX timestamp (adjusted with the programmed antenna delay)  <a href="#abd2c43ace112d8f6092f12750e2276cf">More...</a><br /></td></tr>
<tr class="separator:abd2c43ace112d8f6092f12750e2276cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe474bd1ded51e4e2ad6727097e42eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#aafe474bd1ded51e4e2ad6727097e42eb">dwt_readrxtimestamp</a> (uint8 *timestamp)</td></tr>
<tr class="memdesc:aafe474bd1ded51e4e2ad6727097e42eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to read the RX timestamp (adjusted time of arrival)  <a href="#aafe474bd1ded51e4e2ad6727097e42eb">More...</a><br /></td></tr>
<tr class="separator:aafe474bd1ded51e4e2ad6727097e42eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73de088c14f6ce3e2c1e9b0e3c4f80b0"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#a73de088c14f6ce3e2c1e9b0e3c4f80b0">dwt_readrxtimestamphi32</a> (void)</td></tr>
<tr class="memdesc:a73de088c14f6ce3e2c1e9b0e3c4f80b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to read the high 32-bits of the RX timestamp (adjusted with the programmed antenna delay)  <a href="#a73de088c14f6ce3e2c1e9b0e3c4f80b0">More...</a><br /></td></tr>
<tr class="separator:a73de088c14f6ce3e2c1e9b0e3c4f80b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38247e31a5f26a2bb3ae4ca917291225"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#a38247e31a5f26a2bb3ae4ca917291225">dwt_readrxtimestamplo32</a> (void)</td></tr>
<tr class="memdesc:a38247e31a5f26a2bb3ae4ca917291225"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to read the low 32-bits of the RX timestamp (adjusted with the programmed antenna delay)  <a href="#a38247e31a5f26a2bb3ae4ca917291225">More...</a><br /></td></tr>
<tr class="separator:a38247e31a5f26a2bb3ae4ca917291225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61a03379da3059de1dc19edf2b84884"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#ae61a03379da3059de1dc19edf2b84884">dwt_readsystimestamphi32</a> (void)</td></tr>
<tr class="memdesc:ae61a03379da3059de1dc19edf2b84884"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to read the high 32-bits of the system time.  <a href="#ae61a03379da3059de1dc19edf2b84884">More...</a><br /></td></tr>
<tr class="separator:ae61a03379da3059de1dc19edf2b84884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f5d6beb5e969d4e0a0efe7a2f89f50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#ab5f5d6beb5e969d4e0a0efe7a2f89f50">dwt_readsystime</a> (uint8 *timestamp)</td></tr>
<tr class="memdesc:ab5f5d6beb5e969d4e0a0efe7a2f89f50"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to read the system time.  <a href="#ab5f5d6beb5e969d4e0a0efe7a2f89f50">More...</a><br /></td></tr>
<tr class="separator:ab5f5d6beb5e969d4e0a0efe7a2f89f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e71d5ee3dae6c49f15e1a0c2f392e19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#a0e71d5ee3dae6c49f15e1a0c2f392e19">dwt_forcetrxoff</a> (void)</td></tr>
<tr class="memdesc:a0e71d5ee3dae6c49f15e1a0c2f392e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to turn off the transceiver.  <a href="#a0e71d5ee3dae6c49f15e1a0c2f392e19">More...</a><br /></td></tr>
<tr class="separator:a0e71d5ee3dae6c49f15e1a0c2f392e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef6a00fac7f5e6d2e3d7ef7e138a3e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#afef6a00fac7f5e6d2e3d7ef7e138a3e4">dwt_syncrxbufptrs</a> (void)</td></tr>
<tr class="memdesc:afef6a00fac7f5e6d2e3d7ef7e138a3e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function synchronizes rx buffer pointers need to make sure that the host/IC buffer pointers are aligned before starting RX  <a href="#afef6a00fac7f5e6d2e3d7ef7e138a3e4">More...</a><br /></td></tr>
<tr class="separator:afef6a00fac7f5e6d2e3d7ef7e138a3e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc5ae068950e6cec0eeb9461034abba1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#abc5ae068950e6cec0eeb9461034abba1">dwt_rxenable</a> (int mode)</td></tr>
<tr class="memdesc:abc5ae068950e6cec0eeb9461034abba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This call turns on the receiver, can be immediate or delayed (depending on the mode parameter). In the case of a "late" error the receiver will only be turned on if the DWT_IDLE_ON_DLY_ERR is not set. The receiver will stay turned on, listening to any messages until it either receives a good frame, an error (CRC, PHY header, Reed Solomon) or it times out (SFD, Preamble or Frame).  <a href="#abc5ae068950e6cec0eeb9461034abba1">More...</a><br /></td></tr>
<tr class="separator:abc5ae068950e6cec0eeb9461034abba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ee6802d932e014e9613b6a317a0c0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#a03ee6802d932e014e9613b6a317a0c0f">dwt_setsniffmode</a> (int enable, uint8 timeOn, uint8 timeOff)</td></tr>
<tr class="memdesc:a03ee6802d932e014e9613b6a317a0c0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">enable/disable and configure SNIFF mode.  <a href="#a03ee6802d932e014e9613b6a317a0c0f">More...</a><br /></td></tr>
<tr class="separator:a03ee6802d932e014e9613b6a317a0c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0780ef07f4f88d49eb21797bfb9bdba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#ae0780ef07f4f88d49eb21797bfb9bdba">dwt_setlowpowerlistening</a> (int enable)</td></tr>
<tr class="memdesc:ae0780ef07f4f88d49eb21797bfb9bdba"><td class="mdescLeft">&#160;</td><td class="mdescRight">enable/disable low-power listening mode.  <a href="#ae0780ef07f4f88d49eb21797bfb9bdba">More...</a><br /></td></tr>
<tr class="separator:ae0780ef07f4f88d49eb21797bfb9bdba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c0bf12fd6bb1b20fc0fc2eadee3c07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#a76c0bf12fd6bb1b20fc0fc2eadee3c07">dwt_setsnoozetime</a> (uint8 snooze_time)</td></tr>
<tr class="memdesc:a76c0bf12fd6bb1b20fc0fc2eadee3c07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set duration of "short sleep" phase when in low-power listening mode.  <a href="#a76c0bf12fd6bb1b20fc0fc2eadee3c07">More...</a><br /></td></tr>
<tr class="separator:a76c0bf12fd6bb1b20fc0fc2eadee3c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf9c1b9b467e46f9e74f3a9270afadfa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#aaf9c1b9b467e46f9e74f3a9270afadfa">dwt_setdblrxbuffmode</a> (int enable)</td></tr>
<tr class="memdesc:aaf9c1b9b467e46f9e74f3a9270afadfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">This call enables the double receive buffer mode.  <a href="#aaf9c1b9b467e46f9e74f3a9270afadfa">More...</a><br /></td></tr>
<tr class="separator:aaf9c1b9b467e46f9e74f3a9270afadfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4130ae86d8ffa497f23fe0ebd4bc4f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#ab4130ae86d8ffa497f23fe0ebd4bc4f9">dwt_setrxtimeout</a> (uint16 time)</td></tr>
<tr class="memdesc:ab4130ae86d8ffa497f23fe0ebd4bc4f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This call enables RX timeout (SY_STAT_RFTO event)  <a href="#ab4130ae86d8ffa497f23fe0ebd4bc4f9">More...</a><br /></td></tr>
<tr class="separator:ab4130ae86d8ffa497f23fe0ebd4bc4f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89638383ef01d64e974473bcd0736e54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#a89638383ef01d64e974473bcd0736e54">dwt_setpreambledetecttimeout</a> (uint16 timeout)</td></tr>
<tr class="memdesc:a89638383ef01d64e974473bcd0736e54"><td class="mdescLeft">&#160;</td><td class="mdescRight">This call enables preamble timeout (SY_STAT_RXPTO event)  <a href="#a89638383ef01d64e974473bcd0736e54">More...</a><br /></td></tr>
<tr class="separator:a89638383ef01d64e974473bcd0736e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf1aee0830d8979a32dfa6661154a23"><td class="memItemLeft" align="right" valign="top">uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#a8cf1aee0830d8979a32dfa6661154a23">dwt_calibratesleepcnt</a> (void)</td></tr>
<tr class="memdesc:a8cf1aee0830d8979a32dfa6661154a23"><td class="mdescLeft">&#160;</td><td class="mdescRight">calibrates the local oscillator as its frequency can vary between 7 and 13kHz depending on temp and voltage  <a href="#a8cf1aee0830d8979a32dfa6661154a23">More...</a><br /></td></tr>
<tr class="separator:a8cf1aee0830d8979a32dfa6661154a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e185f1e6a39c1172627b046c3a6d199"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#a7e185f1e6a39c1172627b046c3a6d199">dwt_configuresleepcnt</a> (uint16 sleepcnt)</td></tr>
<tr class="memdesc:a7e185f1e6a39c1172627b046c3a6d199"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the sleep counter to new value, this function programs the high 16-bits of the 28-bit counter  <a href="#a7e185f1e6a39c1172627b046c3a6d199">More...</a><br /></td></tr>
<tr class="separator:a7e185f1e6a39c1172627b046c3a6d199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ff6c69ce94fe497339f78d9de5d732"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#a32ff6c69ce94fe497339f78d9de5d732">dwt_configuresleep</a> (uint16 mode, uint8 wake)</td></tr>
<tr class="memdesc:a32ff6c69ce94fe497339f78d9de5d732"><td class="mdescLeft">&#160;</td><td class="mdescRight">configures the device for both DEEP_SLEEP and SLEEP modes, and on-wake mode i.e. before entering the sleep, the device should be programmed for TX or RX, then upon "waking up" the TX/RX settings will be preserved and the device can immediately perform the desired action TX/RX  <a href="#a32ff6c69ce94fe497339f78d9de5d732">More...</a><br /></td></tr>
<tr class="separator:a32ff6c69ce94fe497339f78d9de5d732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bcda8eb0a24c0946465ad85481166d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#a2bcda8eb0a24c0946465ad85481166d3">dwt_entersleep</a> (void)</td></tr>
<tr class="memdesc:a2bcda8eb0a24c0946465ad85481166d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function puts the device into deep sleep or sleep. dwt_configuresleep() should be called first to configure the sleep and on-wake/wake-up parameters.  <a href="#a2bcda8eb0a24c0946465ad85481166d3">More...</a><br /></td></tr>
<tr class="separator:a2bcda8eb0a24c0946465ad85481166d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52eecd2fdc7b931fca120f6c6fcbcbce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#a52eecd2fdc7b931fca120f6c6fcbcbce">dwt_entersleepaftertx</a> (int enable)</td></tr>
<tr class="memdesc:a52eecd2fdc7b931fca120f6c6fcbcbce"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the auto TX to sleep bit. This means that after a frame transmission the device will enter deep sleep mode. The dwt_configuresleep() function needs to be called before this to configure the on-wake settings  <a href="#a52eecd2fdc7b931fca120f6c6fcbcbce">More...</a><br /></td></tr>
<tr class="separator:a52eecd2fdc7b931fca120f6c6fcbcbce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad056cc032701af064553196932a208d7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#ad056cc032701af064553196932a208d7">dwt_spicswakeup</a> (uint8 *buff, uint16 length)</td></tr>
<tr class="memdesc:ad056cc032701af064553196932a208d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">wake up the device from sleep mode using the SPI read, the device will wake up on chip select line going low if the line is held low for at least 500us. To define the length depending on the time one wants to hold the chip select line low, use the following formula:  <a href="#ad056cc032701af064553196932a208d7">More...</a><br /></td></tr>
<tr class="separator:ad056cc032701af064553196932a208d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b601267dcebe5c70acecbaab21ebc9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#a8b601267dcebe5c70acecbaab21ebc9a">dwt_setcallbacks</a> (dwt_cb_t cbTxDone, dwt_cb_t cbRxOk, dwt_cb_t cbRxTo, dwt_cb_t cbRxErr)</td></tr>
<tr class="memdesc:a8b601267dcebe5c70acecbaab21ebc9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to register the different callbacks called when one of the corresponding event occurs.  <a href="#a8b601267dcebe5c70acecbaab21ebc9a">More...</a><br /></td></tr>
<tr class="separator:a8b601267dcebe5c70acecbaab21ebc9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76bf4e88dac23fb2ac0d641f1685ef5c"><td class="memItemLeft" align="right" valign="top">uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#a76bf4e88dac23fb2ac0d641f1685ef5c">dwt_checkirq</a> (void)</td></tr>
<tr class="memdesc:a76bf4e88dac23fb2ac0d641f1685ef5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if the IRQ line is active - this is used instead of interrupt handler.  <a href="#a76bf4e88dac23fb2ac0d641f1685ef5c">More...</a><br /></td></tr>
<tr class="separator:a76bf4e88dac23fb2ac0d641f1685ef5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a846c7cf58edf0cc6a0a1999c13db560d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#a846c7cf58edf0cc6a0a1999c13db560d">dwt_isr</a> (void)</td></tr>
<tr class="memdesc:a846c7cf58edf0cc6a0a1999c13db560d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the DW1000's general Interrupt Service Routine. It will process/report the following events:  <a href="#a846c7cf58edf0cc6a0a1999c13db560d">More...</a><br /></td></tr>
<tr class="separator:a846c7cf58edf0cc6a0a1999c13db560d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f17787cde56846a340d7d2bb087b3e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f17787cde56846a340d7d2bb087b3e3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dwt_lowpowerlistenisr</b> (void)</td></tr>
<tr class="separator:a1f17787cde56846a340d7d2bb087b3e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d5af48d9f27448f280722ffe739952"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#a92d5af48d9f27448f280722ffe739952">dwt_setinterrupt</a> (uint32 bitmask, uint8 enable)</td></tr>
<tr class="memdesc:a92d5af48d9f27448f280722ffe739952"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables the specified events to trigger an interrupt. The following events can be enabled: DWT_INT_TFRS 0x00000080 // frame sent DWT_INT_RFCG 0x00004000 // frame received with good CRC DWT_INT_RPHE 0x00001000 // receiver PHY header error DWT_INT_RFCE 0x00008000 // receiver CRC error DWT_INT_RFSL 0x00010000 // receiver sync loss error DWT_INT_RFTO 0x00020000 // frame wait timeout DWT_INT_RXPTO 0x00200000 // preamble detect timeout DWT_INT_SFDT 0x04000000 // SFD timeout DWT_INT_ARFE 0x20000000 // frame rejected (due to frame filtering configuration)  <a href="#a92d5af48d9f27448f280722ffe739952">More...</a><br /></td></tr>
<tr class="separator:a92d5af48d9f27448f280722ffe739952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22e1b11b2962d30a9a24a859d2ea638a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#a22e1b11b2962d30a9a24a859d2ea638a">dwt_setpanid</a> (uint16 panID)</td></tr>
<tr class="memdesc:a22e1b11b2962d30a9a24a859d2ea638a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to set the PAN ID.  <a href="#a22e1b11b2962d30a9a24a859d2ea638a">More...</a><br /></td></tr>
<tr class="separator:a22e1b11b2962d30a9a24a859d2ea638a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa853fbd7f632f64311624f313378b4d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#aa853fbd7f632f64311624f313378b4d5">dwt_setaddress16</a> (uint16 shortAddress)</td></tr>
<tr class="memdesc:aa853fbd7f632f64311624f313378b4d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to set 16-bit (short) address.  <a href="#aa853fbd7f632f64311624f313378b4d5">More...</a><br /></td></tr>
<tr class="separator:aa853fbd7f632f64311624f313378b4d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd106330865c039785393d9c6f26c471"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#acd106330865c039785393d9c6f26c471">dwt_seteui</a> (uint8 *eui64)</td></tr>
<tr class="memdesc:acd106330865c039785393d9c6f26c471"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to set the EUI 64-bit (long) address.  <a href="#acd106330865c039785393d9c6f26c471">More...</a><br /></td></tr>
<tr class="separator:acd106330865c039785393d9c6f26c471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb1b1a16e57d683ea1d118e13fd32c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#aeeb1b1a16e57d683ea1d118e13fd32c1">dwt_geteui</a> (uint8 *eui64)</td></tr>
<tr class="memdesc:aeeb1b1a16e57d683ea1d118e13fd32c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to get the EUI 64-bit from the DW1000.  <a href="#aeeb1b1a16e57d683ea1d118e13fd32c1">More...</a><br /></td></tr>
<tr class="separator:aeeb1b1a16e57d683ea1d118e13fd32c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40c22f9e785504225f12b66b72f8b4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#ad40c22f9e785504225f12b66b72f8b4e">dwt_otpread</a> (uint32 address, uint32 *array, uint8 length)</td></tr>
<tr class="memdesc:ad40c22f9e785504225f12b66b72f8b4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to read the OTP data from given address into provided array.  <a href="#ad40c22f9e785504225f12b66b72f8b4e">More...</a><br /></td></tr>
<tr class="separator:ad40c22f9e785504225f12b66b72f8b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4add174bb778c66333cc70e0dd0a0b59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#a4add174bb778c66333cc70e0dd0a0b59">dwt_enableframefilter</a> (uint16 bitmask)</td></tr>
<tr class="memdesc:a4add174bb778c66333cc70e0dd0a0b59"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to enable the frame filtering - (the default option is to accept any data and ACK frames with correct destination address.  <a href="#a4add174bb778c66333cc70e0dd0a0b59">More...</a><br /></td></tr>
<tr class="separator:a4add174bb778c66333cc70e0dd0a0b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabda12db0d45afb19d1b0ec538b21f90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#aabda12db0d45afb19d1b0ec538b21f90">dwt_enableautoack</a> (uint8 responseDelayTime)</td></tr>
<tr class="memdesc:aabda12db0d45afb19d1b0ec538b21f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">This call enables the auto-ACK feature. If the responseDelayTime (parameter) is 0, the ACK will be sent a.s.a.p. otherwise it will be sent with a programmed delay (in symbols), max is 255. NOTE: needs to have frame filtering enabled as well.  <a href="#aabda12db0d45afb19d1b0ec538b21f90">More...</a><br /></td></tr>
<tr class="separator:aabda12db0d45afb19d1b0ec538b21f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8851b10687c4ca10cc5005a6dd66eea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#ac8851b10687c4ca10cc5005a6dd66eea">dwt_setrxaftertxdelay</a> (uint32 rxDelayTime)</td></tr>
<tr class="memdesc:ac8851b10687c4ca10cc5005a6dd66eea"><td class="mdescLeft">&#160;</td><td class="mdescRight">This sets the receiver turn on delay time after a transmission of a frame.  <a href="#ac8851b10687c4ca10cc5005a6dd66eea">More...</a><br /></td></tr>
<tr class="separator:ac8851b10687c4ca10cc5005a6dd66eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e661d854937e728b0a2eb28fb1cf47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#a74e661d854937e728b0a2eb28fb1cf47">dwt_rxreset</a> (void)</td></tr>
<tr class="memdesc:a74e661d854937e728b0a2eb28fb1cf47"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function resets the receiver of the DW1000  <a href="#a74e661d854937e728b0a2eb28fb1cf47">More...</a><br /></td></tr>
<tr class="separator:a74e661d854937e728b0a2eb28fb1cf47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc6587d548f2c58b2d654d31972fb10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#a4fc6587d548f2c58b2d654d31972fb10">dwt_softreset</a> (void)</td></tr>
<tr class="memdesc:a4fc6587d548f2c58b2d654d31972fb10"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function resets the DW1000  <a href="#a4fc6587d548f2c58b2d654d31972fb10">More...</a><br /></td></tr>
<tr class="separator:a4fc6587d548f2c58b2d654d31972fb10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40433381b22a469f6b9610d57bac631"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#ae40433381b22a469f6b9610d57bac631">dwt_readrxdata</a> (uint8 *buffer, uint16 length, uint16 rxBufferOffset)</td></tr>
<tr class="memdesc:ae40433381b22a469f6b9610d57bac631"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to read the data from the RX buffer, from an offset location give by offset parameter.  <a href="#ae40433381b22a469f6b9610d57bac631">More...</a><br /></td></tr>
<tr class="separator:ae40433381b22a469f6b9610d57bac631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf6f8de27f89c6c6cca06427b4ce91fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#aaf6f8de27f89c6c6cca06427b4ce91fe">dwt_readaccdata</a> (uint8 *buffer, uint16 length, uint16 rxBufferOffset)</td></tr>
<tr class="memdesc:aaf6f8de27f89c6c6cca06427b4ce91fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to read the data from the Accumulator buffer, from an offset location give by offset parameter.  <a href="#aaf6f8de27f89c6c6cca06427b4ce91fe">More...</a><br /></td></tr>
<tr class="separator:aaf6f8de27f89c6c6cca06427b4ce91fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe7596292e52282fb06eb478a615d038"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#afe7596292e52282fb06eb478a615d038">dwt_readdiagnostics</a> (<a class="el" href="structdwt__rxdiag__t.html">dwt_rxdiag_t</a> *diagnostics)</td></tr>
<tr class="memdesc:afe7596292e52282fb06eb478a615d038"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function reads the RX signal quality diagnostic data  <a href="#afe7596292e52282fb06eb478a615d038">More...</a><br /></td></tr>
<tr class="separator:afe7596292e52282fb06eb478a615d038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e0c088d4fb0212ab36f981309822dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#a52e0c088d4fb0212ab36f981309822dc">dwt_loadopsettabfromotp</a> (uint8 ops_sel)</td></tr>
<tr class="memdesc:a52e0c088d4fb0212ab36f981309822dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to select which Operational Parameter Set table to load from OTP memory.  <a href="#a52e0c088d4fb0212ab36f981309822dc">More...</a><br /></td></tr>
<tr class="separator:a52e0c088d4fb0212ab36f981309822dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c7f5ce5d6976a40d6d427bb2d016e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#ad2c7f5ce5d6976a40d6d427bb2d016e7">dwt_configeventcounters</a> (int enable)</td></tr>
<tr class="memdesc:ad2c7f5ce5d6976a40d6d427bb2d016e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to enable/disable the event counter in the IC.  <a href="#ad2c7f5ce5d6976a40d6d427bb2d016e7">More...</a><br /></td></tr>
<tr class="separator:ad2c7f5ce5d6976a40d6d427bb2d016e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2c99979d087ebff243f5b87c75984b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#aa2c99979d087ebff243f5b87c75984b6">dwt_readeventcounters</a> (<a class="el" href="structdwt__deviceentcnts__t.html">dwt_deviceentcnts_t</a> *counters)</td></tr>
<tr class="memdesc:aa2c99979d087ebff243f5b87c75984b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to read the event counters in the IC.  <a href="#aa2c99979d087ebff243f5b87c75984b6">More...</a><br /></td></tr>
<tr class="separator:aa2c99979d087ebff243f5b87c75984b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c755cf533cc78b2d0f5d6ddf5c17bc3"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#a1c755cf533cc78b2d0f5d6ddf5c17bc3">dwt_otpwriteandverify</a> (uint32 value, uint16 address)</td></tr>
<tr class="memdesc:a1c755cf533cc78b2d0f5d6ddf5c17bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to program 32-bit value into the DW1000 OTP memory.  <a href="#a1c755cf533cc78b2d0f5d6ddf5c17bc3">More...</a><br /></td></tr>
<tr class="separator:a1c755cf533cc78b2d0f5d6ddf5c17bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a488c67c0be51d2ad8c91fe4d7a95c527"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#a488c67c0be51d2ad8c91fe4d7a95c527">dwt_setleds</a> (uint8 mode)</td></tr>
<tr class="memdesc:a488c67c0be51d2ad8c91fe4d7a95c527"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to set up Tx/Rx GPIOs which could be used to control LEDs Note: not completely IC dependent, also needs board with LEDS fitted on right I/O lines this function enables GPIOs 2 and 3 which are connected to LED3 and LED4 on EVB1000.  <a href="#a488c67c0be51d2ad8c91fe4d7a95c527">More...</a><br /></td></tr>
<tr class="separator:a488c67c0be51d2ad8c91fe4d7a95c527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78d59beb764c0f944f494aff6175e2fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#a78d59beb764c0f944f494aff6175e2fa">dwt_setxtaltrim</a> (uint8 value)</td></tr>
<tr class="memdesc:a78d59beb764c0f944f494aff6175e2fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to adjust the crystal frequency.  <a href="#a78d59beb764c0f944f494aff6175e2fa">More...</a><br /></td></tr>
<tr class="separator:a78d59beb764c0f944f494aff6175e2fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88935fd3e1ddd66dc7d80a47252c1130"><td class="memItemLeft" align="right" valign="top">uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#a88935fd3e1ddd66dc7d80a47252c1130">dwt_getinitxtaltrim</a> (void)</td></tr>
<tr class="memdesc:a88935fd3e1ddd66dc7d80a47252c1130"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the value of XTAL trim that has been applied during initialisation (dwt_init). This can be either the value read in OTP memory or a default value.  <a href="#a88935fd3e1ddd66dc7d80a47252c1130">More...</a><br /></td></tr>
<tr class="separator:a88935fd3e1ddd66dc7d80a47252c1130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d20dbe26e1f5f9fed12ab007a34cfc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#a2d20dbe26e1f5f9fed12ab007a34cfc2">dwt_configcwmode</a> (uint8 chan)</td></tr>
<tr class="memdesc:a2d20dbe26e1f5f9fed12ab007a34cfc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function sets the DW1000 to transmit cw signal at specific channel frequency  <a href="#a2d20dbe26e1f5f9fed12ab007a34cfc2">More...</a><br /></td></tr>
<tr class="separator:a2d20dbe26e1f5f9fed12ab007a34cfc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a122c057bdd7f37c5d790f9807685baeb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#a122c057bdd7f37c5d790f9807685baeb">dwt_configcontinuousframemode</a> (uint32 framerepetitionrate)</td></tr>
<tr class="memdesc:a122c057bdd7f37c5d790f9807685baeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function sets the DW1000 to continuous tx frame mode for regulatory approvals testing.  <a href="#a122c057bdd7f37c5d790f9807685baeb">More...</a><br /></td></tr>
<tr class="separator:a122c057bdd7f37c5d790f9807685baeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdee6613a871684dacaad1c2752bdc29"><td class="memItemLeft" align="right" valign="top">uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#abdee6613a871684dacaad1c2752bdc29">dwt_readtempvbat</a> (uint8 fastSPI)</td></tr>
<tr class="memdesc:abdee6613a871684dacaad1c2752bdc29"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function reads the battery voltage and temperature of the MP The values read here will be the current values sampled by DW1000 AtoD converters. Note on Temperature: the temperature value needs to be converted to give the real temperature the formula is: 1.13 * reading - 113.0 Note on Voltage: the voltage value needs to be converted to give the real voltage the formula is: 0.0057 * reading + 2.3  <a href="#abdee6613a871684dacaad1c2752bdc29">More...</a><br /></td></tr>
<tr class="separator:abdee6613a871684dacaad1c2752bdc29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b9068165b21da45cea70dfa3eebc2c"><td class="memItemLeft" align="right" valign="top">uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#a49b9068165b21da45cea70dfa3eebc2c">dwt_readwakeuptemp</a> (void)</td></tr>
<tr class="memdesc:a49b9068165b21da45cea70dfa3eebc2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function reads the temperature of the DW1000 that was sampled on waking from Sleep/Deepsleep. They are not current values, but read on last wakeup if DWT_TANDV bit is set in mode parameter of dwt_configuresleep  <a href="#a49b9068165b21da45cea70dfa3eebc2c">More...</a><br /></td></tr>
<tr class="separator:a49b9068165b21da45cea70dfa3eebc2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d0522be00626d15a7ae14e7d699cf9"><td class="memItemLeft" align="right" valign="top">uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#a58d0522be00626d15a7ae14e7d699cf9">dwt_readwakeupvbat</a> (void)</td></tr>
<tr class="memdesc:a58d0522be00626d15a7ae14e7d699cf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function reads the battery voltage of the DW1000 that was sampled on waking from Sleep/Deepsleep. They are not current values, but read on last wakeup if DWT_TANDV bit is set in mode parameter of dwt_configuresleep  <a href="#a58d0522be00626d15a7ae14e7d699cf9">More...</a><br /></td></tr>
<tr class="separator:a58d0522be00626d15a7ae14e7d699cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a7fab402733e52e600afcfbb46e0303"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#a9a7fab402733e52e600afcfbb46e0303">dwt_writetodevice</a> (uint16 recordNumber, uint16 index, uint32 length, const uint8 *buffer)</td></tr>
<tr class="memdesc:a9a7fab402733e52e600afcfbb46e0303"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function is used to write to the DW1000 device registers Notes:  <a href="#a9a7fab402733e52e600afcfbb46e0303">More...</a><br /></td></tr>
<tr class="separator:a9a7fab402733e52e600afcfbb46e0303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1096419ebb1d6ecae23fc30ce823ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#a6e1096419ebb1d6ecae23fc30ce823ea">dwt_readfromdevice</a> (uint16 recordNumber, uint16 index, uint32 length, uint8 *buffer)</td></tr>
<tr class="memdesc:a6e1096419ebb1d6ecae23fc30ce823ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function is used to read from the DW1000 device registers Notes:  <a href="#a6e1096419ebb1d6ecae23fc30ce823ea">More...</a><br /></td></tr>
<tr class="separator:a6e1096419ebb1d6ecae23fc30ce823ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affb3b9f29ff2caa2c4aca269a5f7deed"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#affb3b9f29ff2caa2c4aca269a5f7deed">dwt_read32bitoffsetreg</a> (int regFileID, int regOffset)</td></tr>
<tr class="memdesc:affb3b9f29ff2caa2c4aca269a5f7deed"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function is used to read 32-bit value from the DW1000 device registers  <a href="#affb3b9f29ff2caa2c4aca269a5f7deed">More...</a><br /></td></tr>
<tr class="separator:affb3b9f29ff2caa2c4aca269a5f7deed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b5560f6511157a19dfe48783048fb00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#a4b5560f6511157a19dfe48783048fb00">dwt_write32bitoffsetreg</a> (int regFileID, int regOffset, uint32 regval)</td></tr>
<tr class="memdesc:a4b5560f6511157a19dfe48783048fb00"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function is used to write 32-bit value to the DW1000 device registers  <a href="#a4b5560f6511157a19dfe48783048fb00">More...</a><br /></td></tr>
<tr class="separator:a4b5560f6511157a19dfe48783048fb00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861582ad21e6218d014c35f85e5fcd2b"><td class="memItemLeft" align="right" valign="top">uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#a861582ad21e6218d014c35f85e5fcd2b">dwt_read16bitoffsetreg</a> (int regFileID, int regOffset)</td></tr>
<tr class="memdesc:a861582ad21e6218d014c35f85e5fcd2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function is used to read 16-bit value from the DW1000 device registers  <a href="#a861582ad21e6218d014c35f85e5fcd2b">More...</a><br /></td></tr>
<tr class="separator:a861582ad21e6218d014c35f85e5fcd2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a921bfc2cd011eda367419caa2f1009ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#a921bfc2cd011eda367419caa2f1009ed">dwt_write16bitoffsetreg</a> (int regFileID, int regOffset, uint16 regval)</td></tr>
<tr class="memdesc:a921bfc2cd011eda367419caa2f1009ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function is used to write 16-bit value to the DW1000 device registers  <a href="#a921bfc2cd011eda367419caa2f1009ed">More...</a><br /></td></tr>
<tr class="separator:a921bfc2cd011eda367419caa2f1009ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fecc39f300f2e20a9e2e5fef3db8029"><td class="memItemLeft" align="right" valign="top">uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#a2fecc39f300f2e20a9e2e5fef3db8029">dwt_read8bitoffsetreg</a> (int regFileID, int regOffset)</td></tr>
<tr class="memdesc:a2fecc39f300f2e20a9e2e5fef3db8029"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function is used to read an 8-bit value from the DW1000 device registers  <a href="#a2fecc39f300f2e20a9e2e5fef3db8029">More...</a><br /></td></tr>
<tr class="separator:a2fecc39f300f2e20a9e2e5fef3db8029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa87d1ce03a01b7a022e68a397589b583"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#aa87d1ce03a01b7a022e68a397589b583">dwt_write8bitoffsetreg</a> (int regFileID, int regOffset, uint8 regval)</td></tr>
<tr class="memdesc:aa87d1ce03a01b7a022e68a397589b583"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function is used to write an 8-bit value to the DW1000 device registers  <a href="#aa87d1ce03a01b7a022e68a397589b583">More...</a><br /></td></tr>
<tr class="separator:aa87d1ce03a01b7a022e68a397589b583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf3008869cee5a9019609208fb23155"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7bf3008869cee5a9019609208fb23155"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dwt_setautorxreenable</b> (int enable)</td></tr>
<tr class="separator:a7bf3008869cee5a9019609208fb23155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2308c2e7ccc17b410b2873741f23d5"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#a1d2308c2e7ccc17b410b2873741f23d5">writetospi</a> (uint16 headerLength, const uint8 *headerBuffer, uint32 bodylength, const uint8 *bodyBuffer)=0</td></tr>
<tr class="memdesc:a1d2308c2e7ccc17b410b2873741f23d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">NB: In porting this to a particular microprocessor, the implementer needs to define the two low level abstract functions to write to and read from the SPI the definitions should be in deca_spi.c file. Low level abstract function to write to the SPI Takes two separate byte buffers for write header and write data returns 0 for success, or -1 for error.  <a href="#a1d2308c2e7ccc17b410b2873741f23d5">More...</a><br /></td></tr>
<tr class="separator:a1d2308c2e7ccc17b410b2873741f23d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2319bbf32c9a6a47e588f010013f618c"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#a2319bbf32c9a6a47e588f010013f618c">readfromspi</a> (uint16 headerLength, const uint8 *headerBuffer, uint32 readlength, uint8 *readBuffer)=0</td></tr>
<tr class="memdesc:a2319bbf32c9a6a47e588f010013f618c"><td class="mdescLeft">&#160;</td><td class="mdescRight">NB: In porting this to a particular microprocessor, the implementer needs to define the two low level abstract functions to write to and read from the SPI the definitions should be in deca_spi.c file. Low level abstract function to write to the SPI Takes two separate byte buffers for write header and write data returns 0 for success, or -1 for error.  <a href="#a2319bbf32c9a6a47e588f010013f618c">More...</a><br /></td></tr>
<tr class="separator:a2319bbf32c9a6a47e588f010013f618c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab9cdf72847a8da9deb27cdf4b5af5d"><td class="memItemLeft" align="right" valign="top">virtual decaIrqStatus_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#a9ab9cdf72847a8da9deb27cdf4b5af5d">decamutexon</a> (void)=0</td></tr>
<tr class="memdesc:a9ab9cdf72847a8da9deb27cdf4b5af5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function should disable interrupts. This is called at the start of a critical section It returns the IRQ state before disable, this value is used to re-enable in decamutexoff call.  <a href="#a9ab9cdf72847a8da9deb27cdf4b5af5d">More...</a><br /></td></tr>
<tr class="separator:a9ab9cdf72847a8da9deb27cdf4b5af5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a265f25f599cf452f880ef3e4c4ece62e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#a265f25f599cf452f880ef3e4c4ece62e">decamutexoff</a> (decaIrqStatus_t s)</td></tr>
<tr class="memdesc:a265f25f599cf452f880ef3e4c4ece62e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function should re-enable interrupts, or at least restore their state as returned(&amp;saved) by decamutexon This is called at the end of a critical section.  <a href="#a265f25f599cf452f880ef3e4c4ece62e">More...</a><br /></td></tr>
<tr class="separator:a265f25f599cf452f880ef3e4c4ece62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc468bd72488f23e298ed7cdab4b151"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdw1000__api.html#aecc468bd72488f23e298ed7cdab4b151">deca_sleep</a> (unsigned int time_ms)</td></tr>
<tr class="memdesc:aecc468bd72488f23e298ed7cdab4b151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for a given amount of time. NB: The body of this function is defined in deca_sleep.c and is platform specific.  <a href="#aecc468bd72488f23e298ed7cdab4b151">More...</a><br /></td></tr>
<tr class="separator:aecc468bd72488f23e298ed7cdab4b151"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aecc468bd72488f23e298ed7cdab4b151"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::deca_sleep </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>time_ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for a given amount of time. NB: The body of this function is defined in deca_sleep.c and is platform specific. </p>
<hr/>
<p>input parameters: </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time_ms</td><td>- time to wait in milliseconds</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="a265f25f599cf452f880ef3e4c4ece62e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::decamutexoff </td>
          <td>(</td>
          <td class="paramtype">decaIrqStatus_t&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function should re-enable interrupts, or at least restore their state as returned(&amp;saved) by decamutexon This is called at the end of a critical section. </p>
<hr/>
<p>Note: The body of this function is defined in deca_mutex.c and is platform specific</p>
<p>input parameters: </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>- the state of the DW1000 interrupt as returned by decamutexon</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>returns the state of the DW1000 interrupt </p>

</div>
</div>
<a class="anchor" id="a9ab9cdf72847a8da9deb27cdf4b5af5d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::decamutexon </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function should disable interrupts. This is called at the start of a critical section It returns the IRQ state before disable, this value is used to re-enable in decamutexoff call. </p>
<hr/>
<p>Note: The body of this function is defined in deca_mutex.c and is platform specific</p>
<p>input parameters:</p>
<p>output parameters</p>
<p>returns the state of the DW1000 interrupt </p>

<p>Implemented in <a class="el" href="class_decawave.html#a13f900fbe97c6748d3b48b263898747f">Decawave</a>.</p>

</div>
</div>
<a class="anchor" id="a8cf1aee0830d8979a32dfa6661154a23"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_calibratesleepcnt </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>calibrates the local oscillator as its frequency can vary between 7 and 13kHz depending on temp and voltage </p>
<hr/>
<p>NOTE: this function needs to be run before dwt_configuresleepcnt, so that we know what the counter units are</p>
<p>input parameters</p>
<p>output parameters</p>
<p>returns the number of XTAL/2 cycles per low-power oscillator cycle. LP OSC frequency = 19.2 MHz/return value </p>

</div>
</div>
<a class="anchor" id="a76bf4e88dac23fb2ac0d641f1685ef5c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_checkirq </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function checks if the IRQ line is active - this is used instead of interrupt handler. </p>
<hr/>
<p>input parameters</p>
<p>output parameters</p>
<p>return value is 1 if the IRQS bit is set and 0 otherwise </p>

</div>
</div>
<a class="anchor" id="a122c057bdd7f37c5d790f9807685baeb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_configcontinuousframemode </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>framerepetitionrate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>this function sets the DW1000 to continuous tx frame mode for regulatory approvals testing. </p>
<hr/>
<p>input parameters: </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">framerepetitionrate</td><td>- This is a 32-bit value that is used to set the interval between transmissions. The minimum value is 4. The units are approximately 8 ns. (or more precisely 512/(499.2e6*128) seconds)).</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="a2d20dbe26e1f5f9fed12ab007a34cfc2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_configcwmode </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>this function sets the DW1000 to transmit cw signal at specific channel frequency </p>
<hr/>
<p>input parameters: </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>- specifies the operating channel (e.g. 1, 2, 3, 4, 5, 6 or 7)</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="ad2c7f5ce5d6976a40d6d427bb2d016e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_configeventcounters </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is used to enable/disable the event counter in the IC. </p>
<hr/>
<p>input parameters </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">-</td><td>enable - 1 enables (and reset), 0 disables the event counters output parameters</td></tr>
  </table>
  </dd>
</dl>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="aecb1c479d9cc24d3f204f500040efa18"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_configure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdwt__config__t.html">dwt_config_t</a> *&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function provides the main API for the configuration of the DW1000 and this low-level driver. The input is a pointer to the data structure of type dwt_config_t that holds all the configurable items. The dwt_config_t structure shows which ones are supported. </p>
<hr/>
<p>input parameters </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>- pointer to the configuration structure, which contains the device configuration data.</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="a32ff6c69ce94fe497339f78d9de5d732"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_configuresleep </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>wake</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>configures the device for both DEEP_SLEEP and SLEEP modes, and on-wake mode i.e. before entering the sleep, the device should be programmed for TX or RX, then upon "waking up" the TX/RX settings will be preserved and the device can immediately perform the desired action TX/RX </p>
<hr/>
<p>NOTE: e.g. Tag operation - after deep sleep, the device needs to just load the TX buffer and send the frame</p>
<pre class="fragment"> mode: the array and LDE code (OTP/ROM) and LDO tune, and set sleep persist
 DWT_PRESRV_SLEEP 0x0100 - preserve sleep
 DWT_LOADOPSET    0x0080 - load operating parameter set on wakeup
 DWT_CONFIG       0x0040 - download the AON array into the HIF (configuration download)
 DWT_LOADEUI      0x0008
 DWT_GOTORX       0x0002
 DWT_TANDV        0x0001

 wake: wake up parameters
 DWT_XTAL_EN      0x10 - keep XTAL running during sleep
 DWT_WAKE_SLPCNT  0x8 - wake up after sleep count
 DWT_WAKE_CS      0x4 - wake up on chip select
 DWT_WAKE_WK      0x2 - wake up on WAKEUP PIN
 DWT_SLP_EN       0x1 - enable sleep/deep sleep functionality
</pre><p>input parameters </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>- config on-wake parameters </td></tr>
    <tr><td class="paramname">wake</td><td>- config wake up parameters</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="a7e185f1e6a39c1172627b046c3a6d199"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_configuresleepcnt </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>sleepcnt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>sets the sleep counter to new value, this function programs the high 16-bits of the 28-bit counter </p>
<hr/>
<p>NOTE: this function needs to be run before dwt_configuresleep, also the SPI frequency has to be &lt; 3MHz</p>
<p>input parameters </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sleepcnt</td><td>- this it value of the sleep counter to program</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="a489eba8c79d3539e46352f626568b523"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_configuretxrf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdwt__txconfig__t.html">dwt_txconfig_t</a> *&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function provides the API for the configuration of the TX spectrum including the power and pulse generator delay. The input is a pointer to the data structure of type dwt_txconfig_t that holds all the configurable items. </p>
<hr/>
<p>input parameters </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>- pointer to the txrf configuration structure, which contains the tx rf config data</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="aabda12db0d45afb19d1b0ec538b21f90"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_enableautoack </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>responseDelayTime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This call enables the auto-ACK feature. If the responseDelayTime (parameter) is 0, the ACK will be sent a.s.a.p. otherwise it will be sent with a programmed delay (in symbols), max is 255. NOTE: needs to have frame filtering enabled as well. </p>
<hr/>
<p>input parameters </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">responseDelayTime</td><td>- if non-zero the ACK is sent after this delay, max is 255.</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="a4add174bb778c66333cc70e0dd0a0b59"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_enableframefilter </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>bitmask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is used to enable the frame filtering - (the default option is to accept any data and ACK frames with correct destination address. </p>
<hr/>
<p>input parameters </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">-</td><td>bitmask - enables/disables the frame filtering options according to DWT_FF_NOTYPE_EN 0x000 no frame types allowed DWT_FF_COORD_EN 0x002 behave as coordinator (can receive frames with no destination address (PAN ID has to match)) DWT_FF_BEACON_EN 0x004 beacon frames allowed DWT_FF_DATA_EN 0x008 data frames allowed DWT_FF_ACK_EN 0x010 ack frames allowed DWT_FF_MAC_EN 0x020 mac control frames allowed DWT_FF_RSVD_EN 0x040 reserved frame types allowed</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="a2bcda8eb0a24c0946465ad85481166d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_entersleep </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function puts the device into deep sleep or sleep. dwt_configuresleep() should be called first to configure the sleep and on-wake/wake-up parameters. </p>
<hr/>
<p>input parameters</p>
<p>output parameters</p>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="a52eecd2fdc7b931fca120f6c6fcbcbce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_entersleepaftertx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>sets the auto TX to sleep bit. This means that after a frame transmission the device will enter deep sleep mode. The dwt_configuresleep() function needs to be called before this to configure the on-wake settings </p>
<hr/>
<p>NOTE: the IRQ line has to be low/inactive (i.e. no pending events)</p>
<p>input parameters </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>- 1 to configure the device to enter deep sleep after TX, 0 - disables the configuration</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="a0e71d5ee3dae6c49f15e1a0c2f392e19"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_forcetrxoff </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is used to turn off the transceiver. </p>
<hr/>
<p>input parameters</p>
<p>output parameters</p>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="aeeb1b1a16e57d683ea1d118e13fd32c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_geteui </td>
          <td>(</td>
          <td class="paramtype">uint8 *&#160;</td>
          <td class="paramname"><em>eui64</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is used to get the EUI 64-bit from the DW1000. </p>
<hr/>
<p>input parameters </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eui64</td><td>- this is the pointer to a buffer that will contain the read 64-bit EUI value</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="a88935fd3e1ddd66dc7d80a47252c1130"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_getinitxtaltrim </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function returns the value of XTAL trim that has been applied during initialisation (dwt_init). This can be either the value read in OTP memory or a default value. </p>
<hr/>
<p>NOTE: The value returned by this function is the initial value only! It is not updated on dwt_setxtaltrim calls.</p>
<p>input parameters</p>
<p>output parameters</p>
<p>returns the XTAL trim value set upon initialisation </p>

</div>
</div>
<a class="anchor" id="aaf621b142937858869b2006aeffc8a44"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_getlotid </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is used to return the read lot ID of the device. </p>
<hr/>
<p>NOTE: dwt_initialise() must be called prior to this function so that it can return a relevant value.</p>
<p>input parameters</p>
<p>output parameters</p>
<p>returns the 32 bit lot ID value as programmed in the factory </p>

</div>
</div>
<a class="anchor" id="a11ce0db640417c3c7e9545e903c6c63b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_getpartid </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is used to return the read part ID of the device. </p>
<hr/>
<p>NOTE: dwt_initialise() must be called prior to this function so that it can return a relevant value.</p>
<p>input parameters</p>
<p>output parameters</p>
<p>returns the 32 bit part ID value as programmed in the factory </p>

</div>
</div>
<a class="anchor" id="a0a9391f974438b95468c2e3d62b05760"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_initialise </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function initiates communications with the DW1000 transceiver and reads its DEV_ID register (address 0x00) to verify the IC is one supported by this software (e.g. DW1000 32-bit device ID value is 0xDECA0130). Then it does any initial once only device configurations needed for use and initialises as necessary any static data items belonging to this low-level driver. </p>
<hr/>
<p>NOTES: 1.this function needs to be run before dwt_configuresleep, also the SPI frequency has to be &lt; 3MHz 2.it also reads and applies LDO tune and crystal trim values from OTP memory</p>
<p>input parameters </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>- specifies what configuration to load DWT_LOADUCODE 0x1 - load the LDE microcode from ROM - enabled accurate RX timestamp DWT_LOADNONE 0x0 - do not load any values from OTP memory</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>returns DWT_SUCCESS for success, or DWT_ERROR for error </p>

</div>
</div>
<a class="anchor" id="a846c7cf58edf0cc6a0a1999c13db560d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_isr </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the DW1000's general Interrupt Service Routine. It will process/report the following events: </p>
<hr/>
<pre class="fragment">     - RXFCG (through cbRxOk callback)
     - TXFRS (through cbTxDone callback)
     - RXRFTO/RXPTO (through cbRxTo callback)
     - RXPHE/RXFCE/RXRFSL/RXSFDTO/AFFREJ/LDEERR (through cbRxTo cbRxErr)
   For all events, corresponding interrupts are cleared and necessary resets are performed. In addition, in the RXFCG case,
   received frame information and frame control are read before calling the callback. If double buffering is activated, it
   will also toggle between reception buffers once the reception callback processing has ended.

   /!\ This version of the ISR supports double buffering but does not support automatic RX re-enabling!
</pre><p>NOTE: In PC based system using (Cheetah or ARM) USB to SPI converter there can be no interrupts, however we still need something to take the place of it and operate in a polled way. In an embedded system this function should be configured to be triggered on any of the interrupts described above.</p>
<p>input parameters</p>
<p>output parameters</p>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="a52e0c088d4fb0212ab36f981309822dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_loadopsettabfromotp </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>ops_sel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is used to select which Operational Parameter Set table to load from OTP memory. </p>
<hr/>
<p>input parameters </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ops_sel</td><td>- Operational Parameter Set table to load: DWT_OPSET_64LEN = 0x0 - load the operational parameter set table for 64 length preamble configuration DWT_OPSET_TIGHT = 0x1 - load the operational parameter set table for tight xtal offsets (&lt;1ppm) DWT_OPSET_DEFLT = 0x2 - load the default operational parameter set table (this is loaded from reset)</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="ad40c22f9e785504225f12b66b72f8b4e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_otpread </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32 *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is used to read the OTP data from given address into provided array. </p>
<hr/>
<p>input parameters </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>- this is the OTP address to read from </td></tr>
    <tr><td class="paramname">array</td><td>- this is the pointer to the array into which to read the data </td></tr>
    <tr><td class="paramname">length</td><td>- this is the number of 32 bit words to read (array needs to be at least this length)</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="a7624eff5817f4ce5813f2234b0dfb527"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_otprevision </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is used to return the read OTP revision. </p>
<hr/>
<p>NOTE: dwt_initialise() must be called prior to this function so that it can return a relevant value.</p>
<p>input parameters</p>
<p>output parameters</p>
<p>returns the read OTP revision value </p>

</div>
</div>
<a class="anchor" id="a1c755cf533cc78b2d0f5d6ddf5c17bc3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_otpwriteandverify </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is used to program 32-bit value into the DW1000 OTP memory. </p>
<hr/>
<p>input parameters </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- this is the 32-bit value to be programmed into OTP </td></tr>
    <tr><td class="paramname">address</td><td>- this is the 16-bit OTP address into which the 32-bit value is programmed</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>returns DWT_SUCCESS for success, or DWT_ERROR for error </p>
<p>!!!!!!!!!!!!! NOTE !!!!!!!!!!!!!!!!!!!!! </p>

</div>
</div>
<a class="anchor" id="a861582ad21e6218d014c35f85e5fcd2b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_read16bitoffsetreg </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regFileID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>this function is used to read 16-bit value from the DW1000 device registers </p>
<hr/>
<p>input parameters: </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regFileID</td><td>- ID of register file or buffer being accessed </td></tr>
    <tr><td class="paramname">regOffset</td><td>- the index into register file or buffer being accessed</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>returns 16 bit register value </p>

</div>
</div>
<a class="anchor" id="affb3b9f29ff2caa2c4aca269a5f7deed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_read32bitoffsetreg </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regFileID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>this function is used to read 32-bit value from the DW1000 device registers </p>
<hr/>
<p>input parameters: </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regFileID</td><td>- ID of register file or buffer being accessed </td></tr>
    <tr><td class="paramname">regOffset</td><td>- the index into register file or buffer being accessed</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>returns 32 bit register value </p>

</div>
</div>
<a class="anchor" id="a2fecc39f300f2e20a9e2e5fef3db8029"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_read8bitoffsetreg </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regFileID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>this function is used to read an 8-bit value from the DW1000 device registers </p>
<hr/>
<p>input parameters: </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regFileID</td><td>- ID of register file or buffer being accessed </td></tr>
    <tr><td class="paramname">regOffset</td><td>- the index into register file or buffer being accessed</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>returns 8-bit register value </p>

</div>
</div>
<a class="anchor" id="aaf6f8de27f89c6c6cca06427b4ce91fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_readaccdata </td>
          <td>(</td>
          <td class="paramtype">uint8 *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>rxBufferOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is used to read the data from the Accumulator buffer, from an offset location give by offset parameter. </p>
<hr/>
<p>NOTE: Because of an internal memory access delay when reading the accumulator the first octet output is a dummy octet that should be discarded. This is true no matter what sub-index the read begins at.</p>
<p>input parameters </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>- the buffer into which the data will be read </td></tr>
    <tr><td class="paramname">length</td><td>- the length of data to read (in bytes) </td></tr>
    <tr><td class="paramname">accOffset</td><td>- the offset in the acc buffer from which to read the data</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="a522b01e864c59d6d1b63fdec17a3d84c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_readdevid </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is used to return the read device type and revision information of the DW1000 device (MP part is 0xDECA0130) </p>
<hr/>
<p>input parameters</p>
<p>output parameters</p>
<p>returns the read value which for DW1000 is 0xDECA0130 </p>

</div>
</div>
<a class="anchor" id="afe7596292e52282fb06eb478a615d038"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_readdiagnostics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdwt__rxdiag__t.html">dwt_rxdiag_t</a> *&#160;</td>
          <td class="paramname"><em>diagnostics</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>this function reads the RX signal quality diagnostic data </p>
<hr/>
<p>input parameters </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">diagnostics</td><td>- diagnostic structure pointer, this will contain the diagnostic data read from the DW1000</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="aa2c99979d087ebff243f5b87c75984b6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_readeventcounters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdwt__deviceentcnts__t.html">dwt_deviceentcnts_t</a> *&#160;</td>
          <td class="paramname"><em>counters</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is used to read the event counters in the IC. </p>
<hr/>
<p>input parameters </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">counters</td><td>- pointer to the dwt_deviceentcnts_t structure which will hold the read data</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="a6e1096419ebb1d6ecae23fc30ce823ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_readfromdevice </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>recordNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8 *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>this function is used to read from the DW1000 device registers Notes: </p>
<hr/>
<pre class="fragment">   1. Firstly we create a header (the first byte is a header byte)
   a. check if sub index is used, if subindexing is used - set bit-6 to 1 to signify that the sub-index address follows the register index byte
   b. set bit-7 (or with 0x80) for write operation
   c. if extended sub address index is used (i.e. if index &gt; 127) set bit-7 of the first sub-index byte following the first header byte

   2. Write the header followed by the data bytes to the DW1000 device
   3. Store the read data in the input buffer
</pre><p>input parameters: </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recordNumber</td><td>- ID of register file or buffer being accessed </td></tr>
    <tr><td class="paramname">index</td><td>- byte index into register file or buffer being accessed </td></tr>
    <tr><td class="paramname">length</td><td>- number of bytes being read </td></tr>
    <tr><td class="paramname">buffer</td><td>- pointer to buffer in which to return the read data.</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="ae40433381b22a469f6b9610d57bac631"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_readrxdata </td>
          <td>(</td>
          <td class="paramtype">uint8 *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>rxBufferOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is used to read the data from the RX buffer, from an offset location give by offset parameter. </p>
<hr/>
<p>input parameters </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>- the buffer into which the data will be read </td></tr>
    <tr><td class="paramname">length</td><td>- the length of data to read (in bytes) </td></tr>
    <tr><td class="paramname">rxBufferOffset</td><td>- the offset in the rx buffer from which to read the data</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="aafe474bd1ded51e4e2ad6727097e42eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_readrxtimestamp </td>
          <td>(</td>
          <td class="paramtype">uint8 *&#160;</td>
          <td class="paramname"><em>timestamp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is used to read the RX timestamp (adjusted time of arrival) </p>
<hr/>
<p>input parameters </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timestamp</td><td>- a pointer to a 5-byte buffer which will store the read RX timestamp time</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters - the timestamp buffer will contain the value after the function call</p>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="a73de088c14f6ce3e2c1e9b0e3c4f80b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_readrxtimestamphi32 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is used to read the high 32-bits of the RX timestamp (adjusted with the programmed antenna delay) </p>
<hr/>
<p>input parameters</p>
<p>output parameters</p>
<p>returns high 32-bits of RX timestamp </p>

</div>
</div>
<a class="anchor" id="a38247e31a5f26a2bb3ae4ca917291225"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_readrxtimestamplo32 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is used to read the low 32-bits of the RX timestamp (adjusted with the programmed antenna delay) </p>
<hr/>
<p>input parameters</p>
<p>output parameters</p>
<p>returns low 32-bits of RX timestamp </p>

</div>
</div>
<a class="anchor" id="ab5f5d6beb5e969d4e0a0efe7a2f89f50"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_readsystime </td>
          <td>(</td>
          <td class="paramtype">uint8 *&#160;</td>
          <td class="paramname"><em>timestamp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is used to read the system time. </p>
<hr/>
<p>input parameters </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timestamp</td><td>- a pointer to a 5-byte buffer which will store the read system time</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timestamp</td><td>- the timestamp buffer will contain the value after the function call</td></tr>
  </table>
  </dd>
</dl>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="ae61a03379da3059de1dc19edf2b84884"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_readsystimestamphi32 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is used to read the high 32-bits of the system time. </p>
<hr/>
<p>input parameters</p>
<p>output parameters</p>
<p>returns high 32-bits of system time timestamp </p>

</div>
</div>
<a class="anchor" id="abdee6613a871684dacaad1c2752bdc29"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_readtempvbat </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>fastSPI</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>this function reads the battery voltage and temperature of the MP The values read here will be the current values sampled by DW1000 AtoD converters. Note on Temperature: the temperature value needs to be converted to give the real temperature the formula is: 1.13 * reading - 113.0 Note on Voltage: the voltage value needs to be converted to give the real voltage the formula is: 0.0057 * reading + 2.3 </p>
<hr/>
<p>NB: To correctly read the temperature this read should be done with xtal clock however that means that the receiver will be switched off, if receiver needs to be on then the timer is used to make sure the value is stable before reading</p>
<p>input parameters: </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fastSPI</td><td>- set to 1 if SPI rate &gt; than 3MHz is used</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>returns (temp_raw&lt;&lt;8)|(vbat_raw) </p>

</div>
</div>
<a class="anchor" id="aadd7a5a50c8a581d221d665120de1e56"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_readtxtimestamp </td>
          <td>(</td>
          <td class="paramtype">uint8 *&#160;</td>
          <td class="paramname"><em>timestamp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is used to read the TX timestamp (adjusted with the programmed antenna delay) </p>
<hr/>
<p>input parameters </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timestamp</td><td>- a pointer to a 5-byte buffer which will store the read TX timestamp time</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters - the timestamp buffer will contain the value after the function call</p>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="a08fbdf70d9aa5cb3b03584cb5be0fe07"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_readtxtimestamphi32 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is used to read the high 32-bits of the TX timestamp (adjusted with the programmed antenna delay) </p>
<hr/>
<p>input parameters</p>
<p>output parameters</p>
<p>returns high 32-bits of TX timestamp </p>

</div>
</div>
<a class="anchor" id="abd2c43ace112d8f6092f12750e2276cf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_readtxtimestamplo32 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is used to read the low 32-bits of the TX timestamp (adjusted with the programmed antenna delay) </p>
<hr/>
<p>input parameters</p>
<p>output parameters</p>
<p>returns low 32-bits of TX timestamp </p>

</div>
</div>
<a class="anchor" id="a49b9068165b21da45cea70dfa3eebc2c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_readwakeuptemp </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>this function reads the temperature of the DW1000 that was sampled on waking from Sleep/Deepsleep. They are not current values, but read on last wakeup if DWT_TANDV bit is set in mode parameter of dwt_configuresleep </p>
<hr/>
<p>input parameters:</p>
<p>output parameters:</p>
<p>returns: 8-bit raw temperature sensor value </p>

</div>
</div>
<a class="anchor" id="a58d0522be00626d15a7ae14e7d699cf9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_readwakeupvbat </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>this function reads the battery voltage of the DW1000 that was sampled on waking from Sleep/Deepsleep. They are not current values, but read on last wakeup if DWT_TANDV bit is set in mode parameter of dwt_configuresleep </p>
<hr/>
<p>input parameters:</p>
<p>output parameters:</p>
<p>returns: 8-bit raw battery voltage sensor value </p>

</div>
</div>
<a class="anchor" id="abc5ae068950e6cec0eeb9461034abba1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_rxenable </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This call turns on the receiver, can be immediate or delayed (depending on the mode parameter). In the case of a "late" error the receiver will only be turned on if the DWT_IDLE_ON_DLY_ERR is not set. The receiver will stay turned on, listening to any messages until it either receives a good frame, an error (CRC, PHY header, Reed Solomon) or it times out (SFD, Preamble or Frame). </p>
<hr/>
<p>input parameters </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>- this can be one of the following allowed values:</td></tr>
  </table>
  </dd>
</dl>
<p>DWT_START_RX_IMMEDIATE 0 used to enbale receiver immediately DWT_START_RX_DELAYED 1 used to set up delayed RX, if "late" error triggers, then the RX will be enabled immediately (DWT_START_RX_DELAYED | DWT_IDLE_ON_DLY_ERR) 3 used to disable re-enabling of receiver if delayed RX failed due to "late" error (DWT_START_RX_IMMEDIATE | DWT_NO_SYNC_PTRS) 4 used to re-enable RX without trying to sync IC and host side buffer pointers, typically when performing manual RX re-enabling in double buffering mode</p>
<p>returns DWT_SUCCESS for success, or DWT_ERROR for error (e.g. a delayed receive enable will be too far in the future if delayed time has passed) </p>

</div>
</div>
<a class="anchor" id="a74e661d854937e728b0a2eb28fb1cf47"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_rxreset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>this function resets the receiver of the DW1000 </p>
<hr/>
<p>input parameters:</p>
<p>output parameters</p>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="aa853fbd7f632f64311624f313378b4d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_setaddress16 </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>shortAddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is used to set 16-bit (short) address. </p>
<hr/>
<p>input parameters </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shortAddress</td><td>- this sets the 16 bit short address</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="a8b601267dcebe5c70acecbaab21ebc9a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_setcallbacks </td>
          <td>(</td>
          <td class="paramtype">dwt_cb_t&#160;</td>
          <td class="paramname"><em>cbTxDone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dwt_cb_t&#160;</td>
          <td class="paramname"><em>cbRxOk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dwt_cb_t&#160;</td>
          <td class="paramname"><em>cbRxTo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dwt_cb_t&#160;</td>
          <td class="paramname"><em>cbRxErr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function is used to register the different callbacks called when one of the corresponding event occurs. </p>
<hr/>
<p>NOTE: Callbacks can be undefined (set to NULL). In this case, dwt_isr() will process the event as usual but the 'null' callback will not be called.</p>
<p>input parameters </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cbTxDone</td><td>- the pointer to the TX confirmation event callback function </td></tr>
    <tr><td class="paramname">cbRxOk</td><td>- the pointer to the RX good frame event callback function </td></tr>
    <tr><td class="paramname">cbRxTo</td><td>- the pointer to the RX timeout events callback function </td></tr>
    <tr><td class="paramname">cbRxErr</td><td>- the pointer to the RX error events callback function</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="aaf9c1b9b467e46f9e74f3a9270afadfa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_setdblrxbuffmode </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This call enables the double receive buffer mode. </p>
<hr/>
<p>input parameters </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>- 1 to enable, 0 to disable the double buffer mode</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="aef63c9c3329bef4e5e5700daa56254b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_setdelayedtrxtime </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>starttime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This API function configures the delayed transmit time or the delayed RX on time. </p>
<hr/>
<p>input parameters </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">starttime</td><td>- the TX/RX start time (the 32 bits should be the high 32 bits of the system time at which to send the message, or at which to turn on the receiver)</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters none</p>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="acd106330865c039785393d9c6f26c471"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_seteui </td>
          <td>(</td>
          <td class="paramtype">uint8 *&#160;</td>
          <td class="paramname"><em>eui64</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is used to set the EUI 64-bit (long) address. </p>
<hr/>
<p>input parameters </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eui64</td><td>- this is the pointer to a buffer that contains the 64bit address</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="a3805ef20b4a000288da6e9917c35afb6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_setfinegraintxseq </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function enables/disables the fine grain TX sequencing (enabled by default). </p>
<hr/>
<p>input parameters </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>- 1 to enable fine grain TX sequencing, 0 to disable it.</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters none</p>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="a82aac601a54c569d7bc6a74deacb5b02"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_setgpiodirection </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>gpioNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is used to set GPIO direction as an input (1) or output (0) </p>
<hr/>
<p>input parameters </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpioNum</td><td>- this is the GPIO to configure - see GxM0... GxM8 in the deca_regs.h file </td></tr>
    <tr><td class="paramname">direction</td><td>- this sets the GPIO direction - see GxP0... GxP8 in the deca_regs.h file</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="a04d20df2f7ff11cd107e70c56ad2ab89"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_setgpiovalue </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>gpioNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is used to set GPIO value as (1) or (0) only applies if the GPIO is configured as output. </p>
<hr/>
<p>input parameters </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpioNum</td><td>- this is the GPIO to configure - see GxM0... GxM8 in the deca_regs.h file </td></tr>
    <tr><td class="paramname">value</td><td>- this sets the GPIO value - see GDP0... GDP8 in the deca_regs.h file</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="a92d5af48d9f27448f280722ffe739952"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dw1000_api::dwt_setinterrupt </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>bitmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function enables the specified events to trigger an interrupt. The following events can be enabled: DWT_INT_TFRS 0x00000080 // frame sent DWT_INT_RFCG 0x00004000 // frame received with good CRC DWT_INT_RPHE 0x00001000 // receiver PHY header error DWT_INT_RFCE 0x00008000 // receiver CRC error DWT_INT_RFSL 0x00010000 // receiver sync loss error DWT_INT_RFTO 0x00020000 // frame wait timeout DWT_INT_RXPTO 0x00200000 // preamble detect timeout DWT_INT_SFDT 0x04000000 // SFD timeout DWT_INT_ARFE 0x20000000 // frame rejected (due to frame filtering configuration) </p>
<hr/>
<p>input parameters: </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitmask</td><td>- sets the events which will generate interrupt </td></tr>
    <tr><td class="paramname">enable</td><td>- if set the interrupts are enabled else they are cleared</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="a488c67c0be51d2ad8c91fe4d7a95c527"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_setleds </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is used to set up Tx/Rx GPIOs which could be used to control LEDs Note: not completely IC dependent, also needs board with LEDS fitted on right I/O lines this function enables GPIOs 2 and 3 which are connected to LED3 and LED4 on EVB1000. </p>
<hr/>
<p>input parameters </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>- this is a bit field interpreted as follows:<ul>
<li>bit 0: 1 to enable LEDs, 0 to disable them</li>
<li>bit 1: 1 to make LEDs blink once on init. Only valid if bit 0 is set (enable LEDs)</li>
<li>bit 2 to 7: reserved</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters none</p>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="aaa39ce1feb99e92b21eb41138c760526"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_setlnapamode </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lna</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is used to enable GPIO for external LNA or PA functionality - HW dependent, consult the DW1000 User Manual. This can also be used for debug as enabling TX and RX GPIOs is quite handy to monitor DW1000's activity. </p>
<hr/>
<p>NOTE: Enabling PA functionality requires that fine grain TX sequencing is deactivated. This can be done using dwt_setfinegraintxseq().</p>
<p>input parameters </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lna</td><td>- 1 to enable LNA functionality, 0 to disable it </td></tr>
    <tr><td class="paramname">pa</td><td>- 1 to enable PA functionality, 0 to disable it</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="ae0780ef07f4f88d49eb21797bfb9bdba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_setlowpowerlistening </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>enable/disable low-power listening mode. </p>
<hr/>
<p>Low-power listening is a feature whereby the DW1000 is predominantly in the SLEEP state but wakes periodically, (after this "long sleep"), for a very short time to sample the air for a preamble sequence. This preamble sampling "listening" phase is actually two reception phases separated by a "short sleep" time. See DW1000 User Manual section "Low-Power
Listening" for more details.</p>
<p>NOTE: Before enabling low-power listening, the following functions have to be called to fully configure it:</p><ul>
<li>dwt_configuresleep() to configure long sleep phase. "mode" parameter should at least have DWT_PRESRV_SLEEP, DWT_CONFIG and DWT_RX_EN set and "wake" parameter should at least have both DWT_WAKE_SLPCNT and DWT_SLP_EN set.</li>
<li>dwt_calibratesleepcnt() and dwt_configuresleepcnt() to define the "long sleep" phase duration.</li>
<li>dwt_setsnoozetime() to define the "short sleep" phase duration.</li>
<li>dwt_setpreambledetecttimeout() to define the reception phases duration.</li>
<li>dwt_setinterrupt() to activate RX good frame interrupt (DWT_INT_RFCG) only. When configured, low-power listening mode can be triggered either by putting the DW1000 to sleep (using dwt_entersleep()) or by activating reception (using dwt_rxenable()).</li>
</ul>
<p>Please refer to the low-power listening examples (examples 8a/8b accompanying the API distribution on Decawave's website). They form a working example code that shows how to use low-power listening correctly.</p>
<p>input parameters: </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>- 1 to enable low-power listening, 0 to disable.</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="a22e1b11b2962d30a9a24a859d2ea638a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_setpanid </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>panID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is used to set the PAN ID. </p>
<hr/>
<p>input parameters </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">panID</td><td>- this is the PAN ID</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="a89638383ef01d64e974473bcd0736e54"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_setpreambledetecttimeout </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This call enables preamble timeout (SY_STAT_RXPTO event) </p>
<hr/>
<p>input parameters </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>- Preamble detection timeout, expressed in multiples of PAC size. The counter automatically adds 1 PAC size to the value set. Min value that can be set is 1 (i.e. a timeout of 2 PAC size).</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="ac8851b10687c4ca10cc5005a6dd66eea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_setrxaftertxdelay </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>rxDelayTime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This sets the receiver turn on delay time after a transmission of a frame. </p>
<hr/>
<p>input parameters </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rxDelayTime</td><td>- (20 bits) - the delay is in UWB microseconds</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="abcb5075d5880708ab2672fc68a88b3b4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_setrxantennadelay </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>antennaDly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This API function writes the antenna delay (in time units) to RX registers. </p>
<hr/>
<p>input parameters: </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rxDelay</td><td>- this is the total (RX) antenna delay value, which will be programmed into the RX register</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="ab4130ae86d8ffa497f23fe0ebd4bc4f9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_setrxtimeout </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This call enables RX timeout (SY_STAT_RFTO event) </p>
<hr/>
<p>input parameters </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>- how long the receiver remains on from the RX enable command The time parameter used here is in 1.0256 us (512/499.2MHz) units If set to 0 the timeout is disabled.</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="af11b146a383c44470807a7badfe3af05"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_setsmarttxpower </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This call enables or disables the smart TX power feature. </p>
<hr/>
<p>input parameters </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>- this enables or disables the TX smart power (1 = enable, 0 = disable)</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="a03ee6802d932e014e9613b6a317a0c0f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_setsniffmode </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>timeOn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>timeOff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>enable/disable and configure SNIFF mode. </p>
<hr/>
<p>SNIFF mode is a low-power reception mode where the receiver is sequenced on and off instead of being on all the time. The time spent in each state (on/off) is specified through the parameters below. See DW1000 User Manual section 4.5 "Low-Power SNIFF mode" for more details.</p>
<p>input parameters: </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>- 1 to enable SNIFF mode, 0 to disable. When 0, all other parameters are not taken into account. </td></tr>
    <tr><td class="paramname">timeOn</td><td>- duration of receiver ON phase, expressed in multiples of PAC size. The counter automatically adds 1 PAC size to the value set. Min value that can be set is 1 (i.e. an ON time of 2 PAC size), max value is 15. </td></tr>
    <tr><td class="paramname">timeOff</td><td>- duration of receiver OFF phase, expressed in multiples of 128/125 �s (~1 �s). Max value is 255.</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="a76c0bf12fd6bb1b20fc0fc2eadee3c07"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_setsnoozetime </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>snooze_time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set duration of "short sleep" phase when in low-power listening mode. </p>
<hr/>
<p>input parameters: </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">snooze_time</td><td>- "short sleep" phase duration, expressed in multiples of 512/19.2 �s (~26.7 �s). The counter automatically adds 1 to the value set. The smallest working value that should be set is 1, i.e. giving a snooze time of 2 units (or ~53 �s).</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="a8c013846be8715310e949145474c5612"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_settxantennadelay </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>antennaDly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This API function writes the antenna delay (in time units) to TX registers. </p>
<hr/>
<p>input parameters: </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">txDelay</td><td>- this is the total (TX) antenna delay value, which will be programmed into the TX delay register</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="a78d59beb764c0f944f494aff6175e2fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_setxtaltrim </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is used to adjust the crystal frequency. </p>
<hr/>
<p>input parameters: </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- crystal trim value (in range 0x0 to 0x1F) 31 steps (~1.5ppm per step)</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="a4fc6587d548f2c58b2d654d31972fb10"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_softreset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>this function resets the DW1000 </p>
<hr/>
<p>input parameters:</p>
<p>output parameters</p>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="ad056cc032701af064553196932a208d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_spicswakeup </td>
          <td>(</td>
          <td class="paramtype">uint8 *&#160;</td>
          <td class="paramname"><em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>wake up the device from sleep mode using the SPI read, the device will wake up on chip select line going low if the line is held low for at least 500us. To define the length depending on the time one wants to hold the chip select line low, use the following formula: </p>
<hr/>
<pre class="fragment"> length (bytes) = time (s) * byte_rate (Hz)
</pre><p>where fastest byte_rate is spi_rate (Hz) / 8 if the SPI is sending the bytes back-to-back. To save time and power, a system designer could determine byte_rate value more precisely.</p>
<p>NOTE: Alternatively the device can be waken up with WAKE_UP pin if configured for that operation</p>
<p>input parameters </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buff</td><td>- this is a pointer to the dummy buffer which will be used in the SPI read transaction used for the WAKE UP of the device </td></tr>
    <tr><td class="paramname">length</td><td>- this is the length of the dummy buffer</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>returns DWT_SUCCESS for success, or DWT_ERROR for error </p>

</div>
</div>
<a class="anchor" id="aa9207625a29c31c96fe40b1a2485eba7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_starttx </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This call initiates the transmission, input parameter indicates which TX mode is used see below. </p>
<hr/>
<p>input parameters: </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>- if 0 immediate TX (no response expected) if 1 delayed TX (no response expected) if 2 immediate TX (response expected - so the receiver will be automatically turned on after TX is done) if 3 delayed TX (response expected - so the receiver will be automatically turned on after TX is done)</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>returns DWT_SUCCESS for success, or DWT_ERROR for error (e.g. a delayed transmission will fail if the delayed time has passed) </p>

</div>
</div>
<a class="anchor" id="afef6a00fac7f5e6d2e3d7ef7e138a3e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_syncrxbufptrs </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>this function synchronizes rx buffer pointers need to make sure that the host/IC buffer pointers are aligned before starting RX </p>
<hr/>
<p>input parameters:</p>
<p>output parameters</p>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="a921bfc2cd011eda367419caa2f1009ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_write16bitoffsetreg </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regFileID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>regval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>this function is used to write 16-bit value to the DW1000 device registers </p>
<hr/>
<p>input parameters: </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regFileID</td><td>- ID of register file or buffer being accessed </td></tr>
    <tr><td class="paramname">regOffset</td><td>- the index into register file or buffer being accessed </td></tr>
    <tr><td class="paramname">regval</td><td>- the value to write</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="a4b5560f6511157a19dfe48783048fb00"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_write32bitoffsetreg </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regFileID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>regval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>this function is used to write 32-bit value to the DW1000 device registers </p>
<hr/>
<p>input parameters: </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regFileID</td><td>- ID of register file or buffer being accessed </td></tr>
    <tr><td class="paramname">regOffset</td><td>- the index into register file or buffer being accessed </td></tr>
    <tr><td class="paramname">regval</td><td>- the value to write</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="aa87d1ce03a01b7a022e68a397589b583"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_write8bitoffsetreg </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regFileID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>regval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>this function is used to write an 8-bit value to the DW1000 device registers </p>
<hr/>
<p>input parameters: </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regFileID</td><td>- ID of register file or buffer being accessed </td></tr>
    <tr><td class="paramname">regOffset</td><td>- the index into register file or buffer being accessed </td></tr>
    <tr><td class="paramname">regval</td><td>- the value to write</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="a9a7fab402733e52e600afcfbb46e0303"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_writetodevice </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>recordNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8 *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>this function is used to write to the DW1000 device registers Notes: </p>
<hr/>
<pre class="fragment">   1. Firstly we create a header (the first byte is a header byte)
   a. check if sub index is used, if subindexing is used - set bit-6 to 1 to signify that the sub-index address follows the register index byte
   b. set bit-7 (or with 0x80) for write operation
   c. if extended sub address index is used (i.e. if index &gt; 127) set bit-7 of the first sub-index byte following the first header byte

   2. Write the header followed by the data bytes to the DW1000 device
</pre><p>input parameters: </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recordNumber</td><td>- ID of register file or buffer being accessed </td></tr>
    <tr><td class="paramname">index</td><td>- byte index into register file or buffer being accessed </td></tr>
    <tr><td class="paramname">length</td><td>- number of bytes being written </td></tr>
    <tr><td class="paramname">buffer</td><td>- pointer to buffer containing the 'length' bytes to be written</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="a720f3107cf837ce51963e1c1b0aa1925"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_writetxdata </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>txFrameLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8 *&#160;</td>
          <td class="paramname"><em>txFrameBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>txBufferOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This API function writes the supplied TX data into the DW1000's TX buffer. The input parameters are the data length in bytes and a pointer to those data bytes. </p>
<hr/>
<p>input parameters </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">txFrameLength</td><td>- This is the total frame length, including the two byte CRC. Note: this is the length of TX message (including the 2 byte CRC) - max is 1023 standard PHR mode allows up to 127 bytes if &gt; 127 is programmed, DWT_PHRMODE_EXT needs to be set in the phrMode configuration see dwt_configure function </td></tr>
    <tr><td class="paramname">txFrameBytes</td><td>- Pointer to the user�s buffer containing the data to send. </td></tr>
    <tr><td class="paramname">txBufferOffset</td><td>- This specifies an offset in the DW1000�s TX Buffer at which to start writing data.</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>returns DWT_SUCCESS for success, or DWT_ERROR for error </p>

</div>
</div>
<a class="anchor" id="a6d450425dbd8c01d0029deca391d3913"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::dwt_writetxfctrl </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>txFrameLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>txBufferOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ranging</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This API function configures the TX frame control register before the transmission of a frame. </p>
<hr/>
<p>input parameters: </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">txFrameLength</td><td>- this is the length of TX message (including the 2 byte CRC) - max is 1023 NOTE: standard PHR mode allows up to 127 bytes if &gt; 127 is programmed, DWT_PHRMODE_EXT needs to be set in the phrMode configuration see dwt_configure function </td></tr>
    <tr><td class="paramname">txBufferOffset</td><td>- the offset in the tx buffer to start writing the data </td></tr>
    <tr><td class="paramname">ranging</td><td>- 1 if this is a ranging frame, else 0</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>no return value </p>

</div>
</div>
<a class="anchor" id="a2319bbf32c9a6a47e588f010013f618c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::readfromspi </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>headerLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8 *&#160;</td>
          <td class="paramname"><em>headerBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>readlength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8 *&#160;</td>
          <td class="paramname"><em>readBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>NB: In porting this to a particular microprocessor, the implementer needs to define the two low level abstract functions to write to and read from the SPI the definitions should be in deca_spi.c file. Low level abstract function to write to the SPI Takes two separate byte buffers for write header and write data returns 0 for success, or -1 for error. </p>
<hr/>
<p>Note: The body of this function is defined in deca_spi.c and is platform specific</p>
<p>input parameters: </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">headerLength</td><td>- number of bytes header to write </td></tr>
    <tr><td class="paramname">headerBuffer</td><td>- pointer to buffer containing the 'headerLength' bytes of header to write </td></tr>
    <tr><td class="paramname">readlength</td><td>- number of bytes data being read </td></tr>
    <tr><td class="paramname">readBuffer</td><td>- pointer to buffer containing to return the data (NB: size required = headerLength + readlength)</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>returns DWT_SUCCESS for success (and the position in the buffer at which data begins), or DWT_ERROR for error </p>

<p>Implemented in <a class="el" href="class_decawave.html#abbf17a3f1c66e52ecb9a6b770cd4fa7d">Decawave</a>.</p>

</div>
</div>
<a class="anchor" id="a1d2308c2e7ccc17b410b2873741f23d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dw1000_api::writetospi </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>headerLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8 *&#160;</td>
          <td class="paramname"><em>headerBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>bodylength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8 *&#160;</td>
          <td class="paramname"><em>bodyBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>NB: In porting this to a particular microprocessor, the implementer needs to define the two low level abstract functions to write to and read from the SPI the definitions should be in deca_spi.c file. Low level abstract function to write to the SPI Takes two separate byte buffers for write header and write data returns 0 for success, or -1 for error. </p>
<hr/>
<p>Note: The body of this function is defined in deca_spi.c and is platform specific</p>
<p>input parameters: </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">headerLength</td><td>- number of bytes header being written </td></tr>
    <tr><td class="paramname">headerBuffer</td><td>- pointer to buffer containing the 'headerLength' bytes of header to be written </td></tr>
    <tr><td class="paramname">bodylength</td><td>- number of bytes data being written </td></tr>
    <tr><td class="paramname">bodyBuffer</td><td>- pointer to buffer containing the 'bodylength' bytes od data to be written</td></tr>
  </table>
  </dd>
</dl>
<p>output parameters</p>
<p>returns DWT_SUCCESS for success, or DWT_ERROR for error </p>

<p>Implemented in <a class="el" href="class_decawave.html#a675e9ded20f5cb38b43937c652c3ae49">Decawave</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>lib/drivers/decawave/decadriver/<a class="el" href="deca__device__api_8hpp_source.html">deca_device_api.hpp</a></li>
<li>lib/drivers/decawave/decadriver/deca_device.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classdw1000__api.html">dw1000_api</a></li>
    <li class="footer">Generated on Tue May 29 2018 05:41:57 for GT RoboCup SSL by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
